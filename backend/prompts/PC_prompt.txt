**Input**: {{user_query}}

**Instructions**:
You will iteratively optimize the original query through a chain of refinement.

**Iteration Steps**:
1. Analysis and Decomposition:
   - Identify the main objective of the query.
   - Identify ambiguous or redundant phrases and elements.
   - Break the user query into smaller, more specific sub-queries.

2. Refinement Loops:
   - Repeat the refinement process {{number_of_iterations}} times.
   - Refine Each Sub-Query:
        • Re-check the context, constraints and relevant details.
        • Rewrite the sub-query to ensure maximum clarity and specificity.
        • Validate logic and consistency; correct if needed.
   - Each sub-query can undergo multiple mini-loops of refining → validating → rewriting
   - **Stopping Criteria**:
       • If the sub-query is sufficiently clear and concise.
       • If further refinements only add minimal or repetitive changes.
       • If you reach a preset maximum iteration count.

3. Chain the Sub-Queries:
   - Arrange the refined sub-queries in a logical sequence: sub-query 1 → sub-query 2 → sub-query 3, etc.
   - Merge them into one coherent flow.
   - Remove any redundant statements or overlapping points.

4. Optimized query construction:
   - Draft a single, unified query that incorporates every refined sub-query.
   - Ensure clarity, completeness, and cohesion.
   - Eliminate any unnecessary filler or ambiguous wording.

5. Final Verification:
   - Confirm the query fully addresses the user’s original query.
   - Make sure no statements are contradictory.
   - Verify that the query is understandable without additional context.

**Output Format**:
   - Provide the result STRICTLY as JSON.
   - For each iteration (1 to {{number_of_iterations}}), provide:
     {
        "Changes": "<brief_summary_of_modifications>"
        "Optimized_Sub_Query": "<refined_sub-query_text>",
     }
   - After the last iteration, present the **Optimized_Query** as a single JSON key-value pair.